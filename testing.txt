------------- Fases en el desarrollo de software-------------------------
1 - Dise√±o
2 - Desarrollo
3 - Pruebas
4 - Producci√≥n

El encontrar los errores seran mas oportunos si se encuentran en las primeras fases y mas complicados de corregir si se encuentran en las ultimas fases.

------------------  Como gestionar los riesgos segun Google: --------------------

Analisis de codigo estatico: En el editor mientras se desarrolla.
Pruebas unitarias: probar nuesto codigo con pruebas
Pruebas de integraci√≥n: como se combinan dos bloques o funcionalidades en conjunto despues de haber cumplido con su funci√≥n en individual.
Revision de codigo
QA(Pruebas de testers): Pruebas automaticas o manuales

---------------- Deuda Tecnica ------------------
Al igual que con las deudas en la vida real, si se endeuda en este momento, puede obtener algo de mayor valor hoy y pagarlo con el tiempo.
Esto significa que debe ver la deuda tecnol√≥gica como una palanca estrat√©gica para el √©xito de su organizaci√≥n a lo largo del tiempo.

Para ver la deuda tecnol√≥gica como una palanca estrat√©gica, debe:

-Reconocer y trabajar con las suposiciones negativas sobre la deuda tecnol√≥gica
-Clasificar y diferenciar los 6 tipos de deuda t√©cnica
-Dimensionar la deuda tecnol√≥gica
-C√≥mo priorizar la deuda tecnol√≥gica (Dentro de la cartera m√°s amplia de trabajo de productos y etapa de la empresa)
https://www.reforge.com/blog/managing-tech-debt

Igual que en las finanzas, las deudas no son buenas ni malas, solo son una estrategia para alcanzar algo y luego se paga.

haciendo pruebas se maneja el
riesgo

Dise√±o
Desarrollo
Pruebas
Producci√≥n
El momento y pruebas dependen de la fase en la que se encuentra la compa√±√≠a:

Tracci√≥n
Inflexi√≥n
Escala
Expansi√≥n
La deuda de deficiencia del desarrollador puede ser alta porque en la fase de tracci√≥n, la compa√±√≠a busca velocidad > precisi√≥n ,
de modo que en esta etapa el testing no se valora, ya que buscan lanzar, lanzar, lanzar‚Ä¶

Cuando se entra a la fase de inflexi√≥n, hay m√°s usuarios y se empiezan a escribir m√°s pruebas, curando la deuda.

------------- Herramientas de Testing ----------------

Estas herramientas mencionadas est√°n clasificadas seg√∫n el tipo o nivel de pruebas a realizar.

Multiprop√≥sito o Robustas
Pueden ejecutar la mayor√≠a de pruebas de la pir√°mide o trofeo, tanto para backend, frontend, integration test, algunas hasta UI y API s testing.
Jest, _Chai, Mocha, Ava, Jasmine _

UI Testing
Pruebas desplegadas en un dispositivo real o simulado bajo un Browser (navegador) automatizando toques y gestos en la aplicaci√≥n.
Playwright, _ Cypress, WebdriverIO, Puppeteer_

API Testing
En general, las APIs no tienen UI, usan protocolos de servicios por peticiones.
Supertest, Dredd, Postman

Pruebas Est√°ticas
Estas pruebas no ejecutan el c√≥digo, estas herramientas se integran al editor de c√≥digo y van analizando si hay alguna mala pr√°ctica.
ESLint, Prettier, Typescript tools (TSLint)

*Todas estas herramientas manejan una sola estructura (de forma), de modo que el lenguaje o framework pasa a un segundo plano
https://2021.stateofjs.com/en-US/libraries/testing/


gitignore.io
https://www.toptal.com/developers/gitignore/

editor config
https://github.com/airbnb/javascript/blob/master/.editorconfig


------------------------------------------------------------
beforeAll(): se ejecuta antes de todas las pruebas.
beforeEach(): se ejecuta antes de cada prueba.
afterEach(): se ejecuta despu√©s de cada prueba.
afterAll(): se ejecuta despu√©s de todas las pruebas
Nota:
Todas estas funciones se ejecutan dentro del alcance del scope.

------------------------Tipos de pruebas-----------------------

Conceptos

SUT (System Under Test): Sujeto Bajo Prueba, por ejemplo, Person ser√≠a nuestro SUT, no necesariamente tiene que ser un sistema.

Validar: A la hora de validar resolvemos la siguiente pregunta: ¬øestamos construyendo el sistema correcto?, por lo general, en la capa de requerimientos con el cliente y si le da valor a √©l.

Verificar: Cuando ya se hacen pruebas, se verifica teniendo en mente la pregunta: ¬øestamos construyendo el sistema correctamente? casi obviando que ya se produce valor al cliente.

En todas las capas se pueden hacer pruebas, incluso sin c√≥digo, como en los UML o en la revisi√≥n con el equipo de Scrum.
.
Tabla capas Vs detalle
.

Pruebas Funcionales
Son las que validan que se cumplan los requerimientos de valor para el cliente (como guardar bien los buenos datos de un usuario); hasta este punto es lo que hemos hecho en VS code. Por norma general, las pruebas unitarias las entrega el desarrollador, el tester se empieza a involucrar en las pruebas de integraci√≥n o E2E.

Pruebas No Funcionales
Verifican m√°s el √≥ptimo manejo de los recursos del software, no el cumplimiento de requisitos pers√©, como lo son pruebas de: +rendimiento +carga o estabilidad +estr√©s +usabilidad +seguridad. Estas pruebas no necesariamente deben estar desde el principio.

.
NOTA: HAy una nueva √°rea de pruebas No Funcionales que se llama üêí Ingenier√≠a del caos, üêí su pionero es Netflix. Consiste en desconectar servicios en producci√≥n, como por ejemplo, desconectar una BD para ver como reacciona el equipo y establecer soluciones.

-----------------------------Metodolog√≠as-----------------------------------------

-TDD (Test Driven Development): Desarrollo guiado por pruebas, donde primero se hacen las pruebas antes de escribir el c√≥digo (primero los expects).

-BDD (Behavior Driven Development): Desarrollo guiado por comportamiento de acuerdo a los requisitos y luego las pruebas.

-AAA ‚ÄúMantra‚Äù para hacer pruebas

________ preparar Arrange | Given dado algo
____________ ejecutar Act | When cuando
resolver hip√≥tesis Assert | Then entonces

concepto Falso Posit√≠vo Cuando una prueba indica un error, pero todo est√° bien, por ejemplo, testeando el m√©todo suma de 1 +1 y pongo el expect en 5, es un falso positivo, luego la prueba est√° mal.

c Falso Negativo Son m√°s comunes, ya que parece que todo est√° normal, pero no se ha identificado el error, el set de pruebas deber√≠a ser m√°s amplio;
esto sucede cuando caemos en tan solo, probar el Happy Path, probar las condiciones en las que sabemos que el sistema funciona, por ejemplo, en el SUT de dividir las primeras pruebas sal√≠an bien porque no se tom√≥ en cuenta la divisi√≥n entre cero 0, luego se hizo la prueba y el refactor. En caso de falso negativo lo mejor es aplicar TDD.

c Sistema Legacy Son sistemas que te piden agregar pruebas a algo funcional, incluso en paralelo; hay que refactorizar los m√©todos enormes a peque√±os para hacer unit test de pocos a muchos m√©todos; legacy no lleva una buena arquitectura.

c Clean Architecture Este patr√≥n lleva buenas pr√°cticas desde el principio, cada m√©todo est√° bien dividido y con responsabilidades acertadas, es mucho m√°s facil de agregar el set de pruebas.

--------------------- Pruebas Unitarias (Aisladas)--------------------------------------
Son las m√°s comunes y se enfocan en probar unidades espec√≠ficas, incluso conectando dependencias como
BD o librer√≠as emuladas (Dummies); se les conoce tambi√©n como pruebas de estado o de caja negra,
ya que solo importan las entradas y las salidas, en algunas ocasiones se hace con dependencias reales.

Una unidad puede ser una funci√≥n o un m√©todo o una clase, depende del paradigma usado en desarrollo
(funcional o POO); una unidad debe tener solo una responsabilidad en espec√≠fico.

Una utilidad importante de las Unit Test es el Cover Report (reporte de cobertura)‚Ä¶

------------------Reporte de Cobertura-----------------------------------

Es una medida porcentual que indica cuanto falta probar del c√≥digo que va a ir a producci√≥n,
cu√°l ya est√° probado, cu√°l no se usa. ISO y la FAA exigen 100% de cobertura, pero en la realidad
no es tan as√≠, por ejemplo hacer test a setter y getters puede llegar a ser innecesario, este 100%
no garantiza que aparezcan errores ni que sean el mejor set de pruebas.

Doubles

-Dummy: Son datos ficticios para llenar informaci√≥n.

-Fake: Son objetos que simulan comportamientos o datos; como un usuario ficticio.

-Stubs: Son proveedores o APIs de tatos preparados (BD Clima).

-Spies: Son como los stubs, pero se dejan espiar su comportamiento, comunicaci√≥n e invocaci√≥n.

-Mocks: Stubs + Spies, pueden estar pre-programados para enviar las respuestas supuestas.


Mocking suplantar un servidor y poner datos fake
SPIES pruebas de caja blanca
FAKER se usa la libreria fakejs  npm install @faker-js/faker --save-dev


------ Pruebas SUPERTEST de integracion test & e2e
Se testean todos los componentes interactuando entre si
